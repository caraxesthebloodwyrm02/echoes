Final Plan — Quantized & Structured
Summary

Use a two-stage scheduling/effort model. Stage A = coarse modulation (50% intensity on 1/4 units with odd-rhythm cadence) to induce exploration and surface ambiguity. Stage B = precision lock (1/16 quantization at 80–85%) to resolve ambiguity, stabilize behavior, and produce merge-ready artifacts.

Ruleset (how quantization maps to delivery)

Unit = 1 "beat" = 1 work sprint day.

1/4 instance = 1 beat grouped into 4-beat blocks (coarse sprint blocks). Apply 50% effort intensity to selected 1/4 blocks to force sparse, exploratory bursts.

Odd time signatures = non-uniform block lengths (3-beat, 5-beat, 7-beat blocks) for modulation. Use these to allocate exploratory tasks that probe edge-cases and plugins.

After Stage A finishes, output will be intentionally ambiguous/unstructured.

Stage B = apply 1/16 quantization across all produced artifacts and schedule. That means subdividing beats into 16 mini-beats and allocating 80–85% deterministic effort to remap, harden, and finalize. This yields deterministic, reviewable outputs.

Timeline & Effort Allocation (example 10 working-day window)

Total window: 10 working days (modifiable).

Stage A — Modulated Exploration (Days 1–4)

Goal: surface unknowns, prototypes, fuzz inputs, plugin experiments.

Days 1–2: Odd-time block 5-beat — Prototype core diff algorithm variants (structure-first, value-first).

Allocation: 50% intensity on 1/4 instances → effective focused bursts: 2 devs × 50% time.

Output: 2 lightweight prototype functions, test fixtures.

Day 3: Odd-time block 3-beat — Plugin hook prototypes and config experiment (numeric tolerance, array-keying).

Allocation: single dev exploratory.

Day 4: Odd-time block 7-beat — Run fuzz + large-payload smoke runs (higher variance). Capture failures and ambiguous outputs.

Deliverables Stage A: prototypes, raw outputs, failure log, ambiguous diff snapshots.

Transition (End Day 4)

Quick triage session: tag ambiguous artifacts for Stage B remap. Produce prioritization list.

Stage B — Precision Quantization (Days 5–10)

Goal: deterministic implementation, tests, docs, PR artifacts.

Day 5: 1/16 quantization ramp (80%) — Convert prototype into diff API shape, deterministic ordering.

Tasks: implement base diff(harmony, melody, cfg) skeleton.

Day 6: 1/16 quantization (85%) — Add compare_dict, compare_list, compare_value. Add numeric tolerance handling. Write unit tests for primitives.

Day 7: 1/16 quantization (85%) — Implement plugin hook interface. Add fixtures for key-based array comparison.

Day 8: 1/16 quantization (80%) — CLI wrapper and example files. Create configs/harmony_diff.yaml. Add cli/examples.sh.

Day 9: 1/16 quantization (85%) — Integration tests, performance smoke on sampled large payload, snapshot outputs.

Day 10: 1/16 quantization (85%) — Docs (docs/HARMONYHUB_DIFF.md), PR metadata in .pending, produce .pending/phase2_report.json.

Effort mapping summary:

Exploration (Stage A) = 40% of calendar window with 50% intensity bursts.

Finalization (Stage B) = 60% of window with 80–85% deterministic execution.

Concrete Artifacts (to be produced in Stage B)

app/harmony/diff_service.py — deterministic diff API.

app/harmony/cli.py — python -m app.harmony.cli diff --harmony <file> --melody <file>.

configs/harmony_diff.yaml — epsilon, array-mode, streaming-window.

tests/unit/test_diff_core.py — unit coverage & edge cases.

tests/integration/test_diff_cli.py — CLI end-to-end.

docs/HARMONYHUB_DIFF.md — design, examples, config, failure modes.

.pending/phase2_report.json — test outputs, readiness flag.

.pending/commit_message.txt, .pending/phase2_pr_template.md, .pending/branch_staging_name.txt.

Acceptance Criteria (quantized thresholds)

Unit tests: pass with exit code 0. Coverage target: branch tests for core logic.

Integration tests: pass end-to-end on canonical fixtures.

Performance: synthetic 10MB payload completes within configured threshold (configurable).

Determinism: outputs stable across two runs on canonical fixtures (byte-stable JSON ordering).

Docs: include one example per command and config entries.

Report: .pending/phase2_report.json -> ready_for_commit: true.

Risk Controls (mapped to quantization)

Ambiguity after Stage A expected. Use a deterministic filter in Stage B that enforces 1/16 quantization 80–85% to remove noise.

Large payload risk -> enable streaming-window and sample-mode in configs/harmony_diff.yaml.

Semantic mismatches -> isolate via plugin normalization step before core diff.

Quick execution checklist (for agent)

Run Stage A prototypes (3 variants) and capture outputs. Tag ambiguous snapshots.

Run triage; create prioritized artifact list.

Execute Stage B per daily quantized plan. Produce artifacts and tests.

Generate .pending/phase2_report.json and PR metadata.

Stop before any git commit/push. Provide report.